<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Climate Spiral</title>
    
    <!-- Load Inter Font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&display=swap" rel="stylesheet">

    <style>
        /* Updated font-family to prioritize Inter */
        body { margin: 0; overflow: hidden; background-color: #050505; color: white; font-family: 'Inter', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        
        /* Icons */
        .icon-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: #333;
            color: white;
            border: 1px solid #555;
            font-size: 1.2rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
            font-family: serif;
            pointer-events: auto;
            flex-shrink: 0; 
            z-index: 25;
            position: relative;
            overflow: hidden;
        }
        .icon-btn:hover { background: #555; }
        .icon-btn.active { background: #555; border-color: #8b9be1; color: #8b9be1; }

        .btn-icon-img {
            width: 60%;
            height: 60%;
            object-fit: contain;
            display: block; /* Default to show if loaded */
        }
        
        .btn-text {
            display: none; /* Hidden by default, shown via onerror */
            line-height: 1;
        }

        /* Bottom Controls Wrapper */
        #bottomWrapper {
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            flex-direction: row; 
            justify-content: flex-end; 
            align-items: center;
            pointer-events: none; 
            gap: 15px;
            z-index: 20;
            height: 40px; /* Explicit height for alignment */
        }

        /* Timeline Container - Fluid Width */
        #timelineContainer {
            position: absolute;
            bottom: 0;
            left: 0; /* Anchored left */
            right: 160px; /* Anchored right (space for 3 buttons + gaps) */
            height: 40px;
            
            background: rgba(0, 0, 0, 0.8);
            padding: 0 15px;
            border-radius: 30px;
            border: 1px solid #333;
            display: flex;
            align-items: center;
            gap: 15px;
            pointer-events: auto;
            
            /* Animation properties */
            transition: opacity 0.3s ease, transform 0.3s ease;
            overflow: hidden;
            white-space: nowrap;
            z-index: 20;
            box-sizing: border-box;
        }

        /* Collapsed State */
        #timelineContainer.collapsed {
            opacity: 0;
            transform: translateY(20px);
            pointer-events: none;
        }
        
        /* Hidden via Settings */
        #timelineContainer.hidden-setting {
            display: none !important;
        }

        /* Timeline Labels Responsive Logic */
        @media (max-width: 600px) {
            #timelineStart, #timelineEnd {
                display: none;
            }
        }

        /* Button Group - Anchored Right */
        #buttonGroup {
            position: absolute;
            bottom: 0;
            right: 0;
            display: flex;
            gap: 10px;
            pointer-events: auto;
            z-index: 25;
        }

        /* Range Slider Styling */
        input[type=range] {
            -webkit-appearance: none; 
            width: 100%; 
            background: transparent; 
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #fff;
            cursor: pointer;
            margin-top: -6px;
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #555;
            border-radius: 2px;
        }
        input[type=range]:focus { outline: none; }

        /* Panels (Info & Settings) */
        .panel {
            position: absolute;
            bottom: 80px;
            right: 20px;
            background: rgba(0, 0, 0, 0.95);
            padding: 20px;
            border-radius: 8px;
            min-width: 260px;
            max-width: 320px; /* Added max-width constraint */
            border: 1px solid #333;
            display: none; 
            z-index: 30;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
            pointer-events: auto;
            max-height: 70vh;
            overflow-y: auto;
        }
        .panel.visible { display: block; }

        /* Typography */
        h1, h2 { margin: 0 0 15px 0; font-size: 1.2rem; color: #ff9999; }
        h2 { color: #8b9be1; font-size: 1.1rem; border-bottom: 1px solid #333; padding-bottom: 10px; }
        p { font-size: 0.9rem; color: #ccc; margin-bottom: 8px; }
        a { color: #8b9be1; text-decoration: none; }
        a:hover { text-decoration: underline; }

        /* Legend */
        .legend {
            margin-top: 15px;
            width: 100%;
            height: 10px;
            /* Updated gradient: Blue(-1) -> White(0) -> Red(1) -> Purple(2) */
            /* Scale: -1 to 2 is range of 3. 0 is at 33.3%, 1 is at 66.6% */
            background: linear-gradient(to right, 
                #0000ff 0%, 
                #ffffff 33.33%, 
                #ff0000 66.66%, 
                #800080 100%);
            border-radius: 2px;
            position: relative; /* For marker positioning */
        }
        
        #legendMarker {
            position: absolute;
            top: -4px;
            bottom: -4px;
            width: 2px;
            background-color: #fff;
            box-shadow: 0 0 4px rgba(0,0,0,0.8);
            left: 33.33%; /* Default center at 0 */
            transition: left 0.1s linear;
            pointer-events: none;
        }

        .legend-labels {
            display: flex;
            justify-content: space-between;
            font-size: 0.8rem;
            margin-top: 4px;
        }

        /* Close Button */
        .close-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            color: #666;
            font-size: 1.2rem;
            cursor: pointer;
            line-height: 1;
        }
        .close-btn:hover { color: white; }

        /* Settings Toggle Rows */
        .setting-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            font-size: 0.9rem;
            color: #ddd;
        }
        
        /* Toggle Switch CSS */
        .switch {
            position: relative;
            display: inline-block;
            width: 36px;
            height: 20px;
            margin-left: 10px;
        }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider-switch {
            position: absolute;
            cursor: pointer;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: #444;
            transition: .3s;
            border-radius: 20px;
        }
        .slider-switch:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 2px;
            bottom: 2px;
            background-color: #aaa;
            transition: .3s;
            border-radius: 50%;
        }
        input:checked + .slider-switch { background-color: #2196F3; }
        input:checked + .slider-switch:before { 
            transform: translateX(16px); 
            background-color: white;
        }
        
        /* Slider Labels */
        .slider-label {
            display:flex; 
            justify-content:space-between; 
            width:100%; 
            margin-bottom:5px; 
            font-size:0.9rem;
        }
        .slider-val {
            color:#8b9be1; 
            font-size:0.8rem;
        }
        
        /* Upload Button */
        .upload-label {
            background: #444;
            color: #fff;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
            border: 1px solid #555;
            transition: background 0.2s;
        }
        .upload-label:hover { background: #555; }
        
        .loading-text {
            color: #f39c12;
            font-size: 0.8rem;
            display: none;
        }

        /* Drag Overlay */
        #dragOverlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8);
            color: white;
            display: none;
            justify-content: center;
            align-items: center;
            font-size: 2rem;
            z-index: 1000;
            pointer-events: none;
            border: 4px dashed #8b9be1;
        }

    </style>
    <!-- Load Three.js from CDN -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="dragOverlay">Drop Data File Here</div>

    <!-- Info Box -->
    <div id="infoPanel" class="panel">
        <button class="close-btn" data-target="infoPanel">×</button>
        <h1>Climate Spiral</h1>
        <p>Visualizing global temperature anomalies relative to the 1951-1980 baseline. Each coil represents a year.</p>
        <p>
            Source: <a href="https://data.giss.nasa.gov/gistemp/" target="_blank">NASA GISS</a><br>
            Code: <a href="https://github.com/BetaNumeric/climate_spiral" target="_blank">GitHub</a>
        </p>
        
        <!-- Live Data Display -->
        <div id="currentDataDisplay" style="margin-top: 15px; padding-top: 10px; border-top: 1px solid #333;">
            <div style="display:flex; justify-content:space-between; align-items:flex-end;">
                <div>
                    <div style="font-size: 0.8rem; color: #aaa;">Date</div>
                    <div style="font-size: 1.1rem; font-weight: bold; color: #fff;">
                        <span id="infoMonth">Jan</span> <span id="infoYear">1880</span>
                    </div>
                </div>
                <div style="text-align:right;">
                    <div style="font-size: 0.8rem; color: #aaa;">Anomaly</div>
                    <div style="font-size: 1.2rem; color: #8b9be1; font-family: monospace;" id="infoTemp">-- °C</div>
                </div>
            </div>
        </div>

        <div class="legend">
            <div id="legendMarker"></div>
        </div>
        <div class="legend-labels">
            <span>-1.0</span>
            <span>0°C</span>
            <span>+1.0</span>
            <span>+2.0</span>
        </div>
    </div>

    <!-- Settings Box -->
    <div id="settingsPanel" class="panel">
        <button class="close-btn" data-target="settingsPanel">×</button>
        <h2>Settings</h2>
        
        <div class="setting-row">
            <span>Show Annotations</span>
            <label class="switch">
                <input type="checkbox" id="helpersToggle" checked>
                <span class="slider-switch"></span>
            </label>
        </div>

        <div class="setting-row">
            <span>Orthographic View</span>
            <label class="switch">
                <input type="checkbox" id="orthoToggle" checked>
                <span class="slider-switch"></span>
            </label>
        </div>
        
        <div class="setting-row">
            <span>Free Camera</span>
            <label class="switch">
                <input type="checkbox" id="freeCameraToggle">
                <span class="slider-switch"></span>
            </label>
        </div>

        <div class="setting-row" id="interpolationRow" style="display:none;">
            <span>Interpolate Gaps</span>
            <label class="switch">
                <input type="checkbox" id="interpolationToggle">
                <span class="slider-switch"></span>
            </label>
        </div>

        <div class="setting-row">
            <span>Smooth Spiral</span>
            <label class="switch">
                <input type="checkbox" id="smoothSpiralToggle" checked>
                <span class="slider-switch"></span>
            </label>
        </div>
        
        <!-- File Upload & Fetch -->
        <div class="setting-row" style="border-top: 1px solid #444; padding-top: 15px; flex-direction:column; align-items:flex-start; gap:10px;">
            <div style="display:flex; justify-content:space-between; width:100%;">
                <span>Data Source <span id="dataOrigin" style="font-size:0.75rem; color:#888; margin-left:5px;">(Init)</span></span>
                <span id="fetchStatus" class="loading-text">Fetching...</span>
            </div>
            <div style="display:flex; gap:10px; width:100%;">
                <button id="fetchBtn" class="upload-label" style="flex:1; border:1px solid #555; background:#3b4cc0;">Fetch Latest</button>
                <label for="fileUpload" class="upload-label" style="flex:1; text-align:center;">
                    Load .txt
                </label>
            </div>
            <input type="file" id="fileUpload" accept=".txt" style="display:none;">
            <p style="font-size:0.75rem; color:#888; margin:0;">"Fetch" tries NASA direct/proxy. Initial load checks local.</p>
        </div>

        <!-- Spacing Slider -->
        <div class="setting-row" style="flex-direction: column; align-items: flex-start;">
            <div class="slider-label">
                <span>Coil Spacing</span>
                <span id="spacingValue" class="slider-val">0.3</span>
            </div>
            <input type="range" id="spacingSlider" min="0.0" max="1.0" step="0.01" value="0.25" style="width:100%;">
        </div>

        <!-- Speed Slider -->
        <div class="setting-row" style="flex-direction: column; align-items: flex-start;">
            <div class="slider-label">
                <span>Animation Speed</span>
                <span id="speedValue" class="slider-val">0.8x</span>
            </div>
            <!-- Updated speed slider: min 0.01, max 1.0, step 0.01 -->
            <input type="range" id="speedSlider" min="0.01" max="1.0" step="0.01" value="0.8" style="width:100%;">
        </div>

        <!-- Export -->
        <div class="setting-row" style="border-top: 1px solid #444; padding-top: 15px;">
            <span>Export 3D Model</span>
            <button id="exportBtn" class="upload-label" style="border:1px solid #555; background:#444;">Export .glb</button>
        </div>
    </div>

    <!-- Bottom Wrapper -->
    <div id="bottomWrapper">
        
        <!-- Timeline Slider (Collapsed by default) -->
        <div id="timelineContainer" class="collapsed">
            <span style="font-size:0.8rem; color:#aaa; min-width:35px;" id="timelineStart">1880</span>
            <input type="range" id="timelineSlider" min="0" max="100" value="0" step="0.1">
            <span style="font-size:0.8rem; color:#aaa; min-width:35px;" id="timelineEnd">2025</span>
        </div>

        <!-- Buttons -->
        <div id="buttonGroup">
            <button id="playBtn" class="icon-btn" title="Play Animation">
                <img src="icons/pause.png" alt="Play" id="playIconImg" class="btn-icon-img" onerror="this.style.display='none'; this.nextElementSibling.style.display='block'">
                <span class="btn-text">❚❚</span>
            </button>
            <button id="settingsBtn" class="icon-btn" title="Settings">
                <img src="icons/settings.png" alt="Settings" class="btn-icon-img" onerror="this.style.display='none'; this.nextElementSibling.style.display='block'">
                <span class="btn-text">⚙</span>
            </button>
            <button id="infoBtn" class="icon-btn" title="Info">
                <img src="icons/info.png" alt="Info" class="btn-icon-img" onerror="this.style.display='none'; this.nextElementSibling.style.display='block'">
                <span class="btn-text">i</span>
            </button>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFExporter } from 'three/addons/exporters/GLTFExporter.js';

        // --- Configuration ---
        const CONFIG = {
            radiusBase: 10,       
            radiusScale: 5,       
            heightPerYear: 0.25, // Updated default spacing
            tubeRadius: 0.12, 
            tubularSegments: 3000, 
            radialSegments: 8,
            frustumSize: 45, // Updated default zoom (smaller frustum = more zoom)    
            colors: {
                cold: new THREE.Color(0x0000ff), // Vivid Blue
                neutral: new THREE.Color(0xffffff), // Pure white
                hot: new THREE.Color(0xff0000),   // Vivid Red
                extreme: new THREE.Color(0x800080) // Purple for > 1.0C
            },
            angleOffset: -Math.PI / 2 // Rotate -90 deg to put Jan at Top
        };
        
        // Updated font to match CSS exactly
        const FONT_FAMILY = '"Inter", sans-serif';
        const MONTHS_NAMES = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

        const INITIAL_DATA_SOURCE = `
Year   Jan  Feb  Mar  Apr  May  Jun  Jul  Aug  Sep  Oct  Nov  Dec    J-D D-N    DJF  MAM  JJA  SON  Year
1880   -19  -25  -10  -17  -11  -22  -19  -11  -15  -24  -23  -18    -18 ***   ****  -13  -17  -21  1880
1890   -43  -45  -41  -30  -40  -25  -28  -39  -37  -25  -44  -32    -36 -36    -39  -37  -31  -35  1890
1900   -37   -6    0  -10   -9  -11  -14   -9   -6    9   -8   -8     -9 -11    -24   -7  -11   -2  1900
1910   -43  -42  -52  -44  -35  -39  -35  -37  -39  -42  -57  -68    -44 -43    -47  -43  -37  -46  1910
1920   -25  -27  -12  -25  -27  -36  -30  -26  -22  -26  -27  -47    -28 -27    -32  -21  -31  -25  1920
1930   -31  -27  -11  -25  -24  -22  -22  -15  -16  -12   17   -6    -16 -20    -38  -20  -20   -4  1930
1940    -1    8    9   17   10   11   12    6   15   10   16   31     12  13     16   12   10   14  1940
1950   -26  -27   -8  -21  -11   -5   -9  -16  -11  -20  -34  -22    -18 -17    -24  -13  -10  -22  1950
1960     0   13  -35  -15   -8   -4   -4    2    7    6  -11   19     -3  -4      4  -19   -2    0  1960
1970     8   22    6    5   -3   -2    2  -10   12    3    2  -12      3   6     18    3   -4    6  1970
1980    29   39   29   30   35   20   22   18   20   13   29   21     26  28     39   31   20   21  1980
1990    41   44   80   56   45   37   46   34   23   45   46   41     45  45     41   61   39   38  1990
2000    25   56   55   56   36   40   39   42   39   27   30   28     39  40     40   49   40   32  2000
2010    75   84   92   85   76   68   63   67   63   71   82   45     73  74     75   84   66   72  2010
2020   118  124  118  112   99   91   89   86   97   87  109   80    101 103    118  110   89   97  2020
2025   138  126  136  123  108  105  102  116  125  119  121  105    119 121    130  122  108  122  2025
`;

        // --- State ---
        let scene, renderer, controls;
        let perspectiveCamera, orthographicCamera, activeCamera;
        let spiralMesh, endCapMesh; 
        let yearLabelsGroup, monthLabelsGroup; 
        let tempGridGroup, tempLabelGroup, tempVerticalGroup; 
        let yearIndicatorMesh, yearIndicatorTexture, yearIndicatorContext;
        let lastDrawnYear = -1; 
        let spiralHeight = 0; 
        let currentMaxAnomaly = 0;
        let currentMinAnomaly = 0; 
        let totalDurationYears = 0; 
        
        let dirLight; // Global ref for update

        // Reused color helper to prevent GC churn
        const _colorHelper = new THREE.Color();
        
        let currentDataText = INITIAL_DATA_SOURCE; 
        let timelineData = []; 
        let generatedGeometryData = null; // Store data for animation mapping
        
        // Animation State
        let isAnimating = false;
        let animationIndex = 0;
        let totalIndices = 0;
        let startYear = 1880;
        let endYear = 2025; 
        let animationSpeed = 0.8; 
        
        // UI State
        let timelineTimeout;

        // --- Initialization ---
        init();
        
        // Initial Draw
        updateDataVisualization();
        
        // Try local data fetch on start
        loadLocalData();
        
        // Start animation automatically
        toggleAnimation();
        
        animate();

        // --- Functions ---

        function init() {
            scene = new THREE.Scene();

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            // Cameras
            const aspect = window.innerWidth / window.innerHeight;
            perspectiveCamera = new THREE.PerspectiveCamera(45, aspect, 1, 1000);
            
            const frustumSize = CONFIG.frustumSize;
            orthographicCamera = new THREE.OrthographicCamera(
                frustumSize * aspect / -2,
                frustumSize * aspect / 2,
                frustumSize / 2,
                frustumSize / -2,
                1,
                2000
            );
            
            // Set initial position for Ortho (Top Down)
            orthographicCamera.position.set(0, 200, 0);
            orthographicCamera.lookAt(0, 0, 0);
            
            // Sync perspective start pos
            perspectiveCamera.position.copy(orthographicCamera.position);

            activeCamera = orthographicCamera;

            // Controls
            controls = new OrbitControls(activeCamera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.autoRotate = false;
            // Lock camera to prevent looking from below ground
            controls.maxPolarAngle = Math.PI / 2; 
            controls.target.set(0, 0, 0); 
            controls.enablePan = false; // Restricted by default

            // Lights - Improved for 3D look
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6); 
            scene.add(ambientLight);
            
            // Global Dir Light to follow camera
            dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
            scene.add(dirLight);
            
            const pointLight = new THREE.PointLight(0xffffff, 0.5);
            pointLight.position.set(0, 20, 0);
            scene.add(pointLight);

            // Year Indicator (3D Mesh)
            createYearIndicator();
            
            // Temp Grid (Static Circles)
            createTemperatureGrid();

            // Drag and Drop
            const dragOverlay = document.getElementById('dragOverlay');
            document.body.addEventListener('dragover', (e) => {
                e.preventDefault();
                dragOverlay.style.display = 'flex';
            });
            document.body.addEventListener('dragleave', (e) => {
                if(e.clientX === 0 && e.clientY === 0) {
                    dragOverlay.style.display = 'none';
                }
            });
            document.body.addEventListener('drop', (e) => {
                e.preventDefault();
                dragOverlay.style.display = 'none';
                const file = e.dataTransfer.files[0];
                if (file) handleFile(file);
            });

            // Listeners
            window.addEventListener('resize', onWindowResize);
            setupUI();
            
            // Initial call to set correct zoom/frustum for current window size
            onWindowResize();
        }

        // Helper to recursively dispose of objects to prevent memory leaks
        function disposeHierarchy(obj) {
            if (!obj) return;
            obj.traverse((child) => {
                if (child.geometry) child.geometry.dispose();
                if (child.material) {
                    if (Array.isArray(child.material)) {
                        child.material.forEach(m => {
                            if(m.map) m.map.dispose();
                            m.dispose();
                        });
                    } else {
                        if(child.material.map) child.material.map.dispose();
                        child.material.dispose();
                    }
                }
            });
        }
        
        function updateSourceLabel(text) {
            const el = document.getElementById('dataOrigin');
            if(el) {
                el.innerText = `(${text})`;
                el.style.color = "#8b9be1"; 
            }
        }

        function handleFile(file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                currentDataText = e.target.result; // Update source
                updateDataVisualization();
                resetAnimation();
                updateSourceLabel("User File");
            };
            reader.readAsText(file);
        }
        
        function fetchRemoteData() {
            const statusEl = document.getElementById('fetchStatus');
            statusEl.style.display = 'block';
            statusEl.innerText = "Fetching NASA...";
            statusEl.style.color = "#f39c12";

            const directUrl = "https://data.giss.nasa.gov/gistemp/tabledata_v4/GLB.Ts+dSST.txt";
            const proxyUrl = "https://corsproxy.io/?" + encodeURIComponent(directUrl);
            
            const onSuccess = (text, sourceLabel) => {
                currentDataText = text;
                updateDataVisualization();
                resetAnimation();
                statusEl.innerText = "Success!";
                statusEl.style.color = "#2ecc71";
                updateSourceLabel(sourceLabel);
                setTimeout(() => { statusEl.style.display = 'none'; }, 3000);
            };

            // 1. Try Direct
            fetch(directUrl)
                .then(response => {
                    if(!response.ok) throw new Error("Direct fetch failed");
                    return response.text();
                })
                .then(text => onSuccess(text, "NASA Direct"))
                .catch(err => {
                    console.log("Direct fetch failed (likely CORS), trying proxy...", err);
                    statusEl.innerText = "Trying Proxy...";
                    
                    // 2. Try Proxy
                    fetch(proxyUrl)
                        .then(response => {
                            if(!response.ok) throw new Error("Proxy fetch failed");
                            return response.text();
                        })
                        .then(text => onSuccess(text, "NASA via proxy"))
                        .catch(finalErr => {
                            console.warn("All fetches failed", finalErr);
                            statusEl.innerText = "Fetch Failed";
                            statusEl.style.color = "#e74c3c";
                        });
                });
        }
        
        function loadLocalData() {
            const statusEl = document.getElementById('fetchStatus');
            statusEl.style.display = 'block';
            statusEl.innerText = "Checking local...";
            statusEl.style.color = "#f39c12";

            fetch('data/GLB.Ts+dSST.txt')
                .then(response => {
                    if(!response.ok) throw new Error("Local data not found");
                    return response.text();
                })
                .then(text => {
                    currentDataText = text;
                    updateDataVisualization();
                    resetAnimation();
                    statusEl.innerText = "Local Data";
                    statusEl.style.color = "#2ecc71";
                    updateSourceLabel("Local Data");
                    setTimeout(() => { statusEl.style.display = 'none'; }, 3000);
                })
                .catch(error => {
                    console.log("Local fetch failed, using embedded data.", error);
                    statusEl.innerText = "";
                    updateSourceLabel("Embedded Data");
                });
        }
        
        function resetAnimation() {
            animationIndex = 0;
            lastDrawnYear = -1; // Force redraw of year
            if(spiralMesh) {
                updateSpiralVisuals(); 
                document.getElementById('timelineSlider').value = 0;
                updateTimelineState(0);
            }
            if (!isAnimating) toggleAnimation();
        }

        // --- Export Function ---
        function exportGLTF() {
            if (!spiralMesh) return;

            const exporter = new GLTFExporter();
            
            // Clone Spiral with full draw range
            // NOTE: The geometry now INCLUDES the start and end caps natively.
            // So we don't need to add separate sphere meshes.
            const spiralClone = spiralMesh.clone();
            spiralClone.geometry = spiralMesh.geometry.clone();
            spiralClone.geometry.setDrawRange(0, Infinity); // Full range (inc. both caps)
            
            // Execute Export
            exporter.parse(
                spiralClone,
                function ( gltf ) {
                    const blob = new Blob( [ gltf ], { type: 'application/octet-stream' } );
                    const url = URL.createObjectURL( blob );
                    const link = document.createElement( 'a' );
                    link.style.display = 'none';
                    link.href = url;
                    link.download = 'climate-spiral.glb';
                    document.body.appendChild( link );
                    link.click();
                    document.body.removeChild( link );
                    URL.revokeObjectURL( url );
                },
                function ( error ) {
                    console.error( 'An error happened during export:', error );
                },
                { binary: true }
            );
        }

        function createYearIndicator() {
            const canvas = document.createElement('canvas');
            canvas.width = 1024; // Increased resolution
            canvas.height = 512; // Increased resolution
            yearIndicatorContext = canvas.getContext('2d');
            
            yearIndicatorTexture = new THREE.CanvasTexture(canvas);
            
            // Material supports tinting with .color
            const material = new THREE.MeshBasicMaterial({ 
                map: yearIndicatorTexture, 
                transparent: true,
                opacity: 0.9,
                side: THREE.DoubleSide,
                color: 0xffffff // Start white
            });
            
            const geometry = new THREE.PlaneGeometry(10, 5); 
            yearIndicatorMesh = new THREE.Mesh(geometry, material);
            
            yearIndicatorMesh.rotation.x = -Math.PI / 2;
            yearIndicatorMesh.position.set(0, 0.1, 0);
            
            scene.add(yearIndicatorMesh);
            updateYearIndicatorText("1880");
        }

        function updateYearIndicatorText(text) {
            // Only update text content if changed (optimization)
            if (text === lastDrawnYear) return;
            lastDrawnYear = text;

            if (!yearIndicatorContext) return;
            const ctx = yearIndicatorContext;
            ctx.clearRect(0, 0, 1024, 512);
            
            // Draw in WHITE so we can tint it with material.color
            ctx.fillStyle = "#ffffff"; 
            
            ctx.font = '400px ' + FONT_FAMILY;
            
            // Manual "Tabular figures" logic to prevent jitter
            // We draw each character individually at a fixed pitch
            const str = text.toString();
            
            // Measure a standard wide digit '0' to determine the fixed cell width
            const digitWidth = ctx.measureText("0").width;
            const step = digitWidth; // Fixed distance between character centers
            
            // Calculate starting X so the whole string is centered at 512
            // (length-1) * step is the distance from center of first char to center of last char
            const startX = 512 - ((str.length - 1) * step / 2);
            
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            for (let i = 0; i < str.length; i++) {
                ctx.fillText(str[i], startX + (i * step), 256);
            }
            
            yearIndicatorTexture.needsUpdate = true;
        }
        
        function createTemperatureGrid() {
            if(tempGridGroup) { disposeHierarchy(tempGridGroup); scene.remove(tempGridGroup); }
            if(tempLabelGroup) { disposeHierarchy(tempLabelGroup); scene.remove(tempLabelGroup); }
            if(tempVerticalGroup) { disposeHierarchy(tempVerticalGroup); scene.remove(tempVerticalGroup); } 
            
            tempGridGroup = new THREE.Group();
            tempLabelGroup = new THREE.Group();
            tempVerticalGroup = new THREE.Group();
            
            const temps = [0, 1, -1];
            
            temps.forEach(temp => {
                const r = CONFIG.radiusBase + (temp * CONFIG.radiusScale);
                const curve = new THREE.EllipseCurve(0, 0, r, r, 0, 2 * Math.PI, false, 0);
                const points = curve.getPoints(64);
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({ color: 0x666666, transparent:true, opacity:0.3 });
                
                const ring = new THREE.LineLoop(geometry, material);
                ring.rotation.x = -Math.PI / 2;
                ring.position.y = -2.0; 
                tempGridGroup.add(ring);
                
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = 512; 
                canvas.height = 256;
                ctx.fillStyle = '#888';
                ctx.font = '80px ' + FONT_FAMILY; 
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const labelText = temp > 0 ? `+${temp}°C` : `${temp}°C`;
                ctx.fillText(labelText, 256, 128);
                
                const texture = new THREE.CanvasTexture(canvas);
                texture.minFilter = THREE.LinearFilter;
                texture.magFilter = THREE.LinearFilter;
                texture.anisotropy = renderer.capabilities.getMaxAnisotropy();

                const meshMat = new THREE.MeshBasicMaterial({ map: texture, transparent:true, opacity:0.6, side: THREE.DoubleSide });
                const geometryPlane = new THREE.PlaneGeometry(6, 3); // Updated scale to match
                const mesh = new THREE.Mesh(geometryPlane, meshMat);
                
                const labelAngle = Math.PI / 4; 
                mesh.position.set(Math.cos(labelAngle)*r, -1.9, Math.sin(labelAngle)*r);
                mesh.rotation.x = -Math.PI / 2;
                
                tempLabelGroup.add(mesh);

                const vertGeo = new THREE.CylinderGeometry(0.03, 0.03, 1, 8);
                const vertMat = new THREE.MeshBasicMaterial({ color: 0x666666, transparent: true, opacity: 0 });
                
                const v1 = new THREE.Mesh(vertGeo, vertMat.clone());
                v1.position.set(r, 0.5, 0);
                tempVerticalGroup.add(v1);
                
                const vSpriteMat = new THREE.SpriteMaterial({ map: texture, transparent: true, opacity: 0 });
                const vLabel = new THREE.Sprite(vSpriteMat);
                vLabel.scale.set(6, 3, 1);
                vLabel.position.set(r, 1, 0);
                vLabel.name = "vLabel";
                tempVerticalGroup.add(vLabel);

                const v2 = new THREE.Mesh(vertGeo, vertMat.clone());
                v2.position.set(-r, 0.5, 0);
                tempVerticalGroup.add(v2);
                
                const vLabel2 = new THREE.Sprite(vSpriteMat.clone());
                vLabel2.scale.set(6, 3, 1);
                vLabel2.position.set(-r, 1, 0);
                vLabel2.name = "vLabel";
                tempVerticalGroup.add(vLabel2);
            });
            
            const azimuth = controls.getAzimuthalAngle();
            const polar = controls.getPolarAngle();
            const opacity = Math.min(1, Math.max(0, polar / 1.2));
            const inverseOpacity = 1 - opacity;

            tempLabelGroup.rotation.y = azimuth;
            tempVerticalGroup.rotation.y = azimuth;
            
            tempLabelGroup.children.forEach(c => c.material.opacity = inverseOpacity * 0.6);
            tempVerticalGroup.children.forEach(c => {
                if(c.name === "vLabel") c.material.opacity = opacity * 0.9;
                else c.material.opacity = opacity * 0.4;
            });
            tempGridGroup.children.forEach(c => {
                 if(c.material) c.material.opacity = inverseOpacity * 0.3;
            });

            scene.add(tempGridGroup);
            scene.add(tempLabelGroup);
            scene.add(tempVerticalGroup);
        }

        function updateTemperatureVerticals(height) {
            if(!tempVerticalGroup) return;
            
            const gridLevel = -2.0;
            const topLevel = height + 2.0;
            const totalLength = topLevel - gridLevel;
            
            const centerY = gridLevel + (totalLength / 2);

            tempVerticalGroup.children.forEach(child => {
                if (child.name === "vLabel") {
                    child.position.y = topLevel + 1.0; 
                } else {
                    child.scale.y = totalLength;
                    child.position.y = centerY;
                }
            });
        }

        function getInterpolatedColor(anomaly) {
            if (anomaly < 0) {
                const t = Math.min(1, Math.abs(anomaly));
                _colorHelper.lerpColors(CONFIG.colors.neutral, CONFIG.colors.cold, t);
            } else if (anomaly <= 1) {
                _colorHelper.lerpColors(CONFIG.colors.neutral, CONFIG.colors.hot, anomaly);
            } else {
                const t = Math.min(1, anomaly - 1);
                _colorHelper.lerpColors(CONFIG.colors.hot, CONFIG.colors.extreme, t);
            }
            return "#" + _colorHelper.getHexString();
        }
        
        // Helper to mix colors directly
        function lerpColor(c1, c2, alpha) {
            return new THREE.Color().lerpColors(c1, c2, alpha);
        }

        function getSpiralColorAtU(u, rawColors) {
            const totalColorPoints = rawColors.length / 3;
            const floatIdx = u * (totalColorPoints - 1);
            const idx1 = Math.floor(floatIdx);
            const idx2 = Math.min(idx1 + 1, totalColorPoints - 1);
            const alpha = floatIdx - idx1;

            const r1 = rawColors[idx1 * 3];
            const g1 = rawColors[idx1 * 3 + 1];
            const b1 = rawColors[idx1 * 3 + 2];
            
            const r2 = rawColors[idx2 * 3];
            const g2 = rawColors[idx2 * 3 + 1];
            const b2 = rawColors[idx2 * 3 + 2];
            
            _colorHelper.setRGB(
                r1 + (r2 - r1) * alpha,
                g1 + (g2 - g1) * alpha,
                b1 + (b2 - b1) * alpha
            );
            return _colorHelper;
        }

        function setupUI() {
            const toggleBtn = document.getElementById('infoBtn');
            const settingsBtn = document.getElementById('settingsBtn');
            const playBtn = document.getElementById('playBtn');
            const infoPanel = document.getElementById('infoPanel');
            const settingsPanel = document.getElementById('settingsPanel');
            
            const orthoSwitch = document.getElementById('orthoToggle');
            const helpersSwitch = document.getElementById('helpersToggle'); 
            const interpSwitch = document.getElementById('interpolationToggle');
            const smoothSpiralSwitch = document.getElementById('smoothSpiralToggle');
            const freeCamSwitch = document.getElementById('freeCameraToggle'); 
            const fileInput = document.getElementById('fileUpload');
            const fetchBtn = document.getElementById('fetchBtn');
            const exportBtn = document.getElementById('exportBtn');
            
            const speedSlider = document.getElementById('speedSlider');
            const timelineSlider = document.getElementById('timelineSlider');
            const spacingSlider = document.getElementById('spacingSlider');
            
            const timelineContainer = document.getElementById('timelineContainer');
            const buttonGroup = document.getElementById('buttonGroup');

            toggleBtn.addEventListener('click', () => {
                infoPanel.classList.toggle('visible');
                settingsPanel.classList.remove('visible');
            });
            settingsBtn.addEventListener('click', () => {
                settingsPanel.classList.toggle('visible');
                infoPanel.classList.remove('visible');
            });
            document.querySelectorAll('.close-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    document.getElementById(e.target.dataset.target).classList.remove('visible');
                });
            });

            orthoSwitch.addEventListener('change', (e) => switchCamera(e.target.checked));
            
            helpersSwitch.addEventListener('change', (e) => {
                const visible = e.target.checked;
                if(yearLabelsGroup) yearLabelsGroup.visible = visible;
                if(monthLabelsGroup) monthLabelsGroup.visible = visible;
                if(yearIndicatorMesh) yearIndicatorMesh.visible = visible;
                if(tempGridGroup) tempGridGroup.visible = visible;
                if(tempLabelGroup) tempLabelGroup.visible = visible;
                if(tempVerticalGroup) tempVerticalGroup.visible = visible;
                if(endCapMesh) endCapMesh.visible = visible;
            });
            
            interpSwitch.addEventListener('change', updateDataVisualization);
            smoothSpiralSwitch.addEventListener('change', updateDataVisualization);
            
            freeCamSwitch.addEventListener('change', (e) => {
                const isFree = e.target.checked;
                controls.enablePan = isFree;
                controls.maxPolarAngle = isFree ? Math.PI : Math.PI / 2;
                if (!isFree) {
                    controls.target.set(0, spiralHeight / 2, 0); 
                    controls.update();
                }
            });

            fileInput.addEventListener('change', (e) => {
                if(e.target.files.length > 0) handleFile(e.target.files[0]);
            });
            
            fetchBtn.addEventListener('click', fetchRemoteData);
            exportBtn.addEventListener('click', exportGLTF);

            const showTimeline = () => {
                clearTimeout(timelineTimeout);
                const containerEl = document.getElementById('timelineContainer');
                if(containerEl) containerEl.classList.remove('collapsed');
            };
            
            const hideTimeline = () => {
                clearTimeout(timelineTimeout);
                timelineTimeout = setTimeout(() => {
                    const containerEl = document.getElementById('timelineContainer');
                    if(containerEl) containerEl.classList.add('collapsed');
                }, 2000);
            };
            
            const timelineContainerEl = document.getElementById('timelineContainer');

            buttonGroup.addEventListener('mouseenter', showTimeline);
            timelineContainerEl.addEventListener('mouseenter', showTimeline);
            buttonGroup.addEventListener('mouseleave', hideTimeline);
            timelineContainerEl.addEventListener('mouseleave', hideTimeline);
            hideTimeline();

            playBtn.addEventListener('click', toggleAnimation);
            
            speedSlider.addEventListener('input', (e) => {
                animationSpeed = parseFloat(e.target.value);
                document.getElementById('speedValue').innerText = animationSpeed + 'x';
            });

            timelineSlider.addEventListener('input', (e) => {
                showTimeline(); 
                if (isAnimating) toggleAnimation(); 
                
                const percent = parseFloat(e.target.value);
                animationIndex = Math.floor((percent / 100) * totalIndices);
                
                updateSpiralVisuals();
                updateTimelineState(animationIndex);
            });
            
            spacingSlider.addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                CONFIG.heightPerYear = val;
                document.getElementById('spacingValue').innerText = val.toFixed(1);
                updateDataVisualization(); 
            });
        }

        function updateTimelineState(index) {
            const progress = index / totalIndices;
            
            if(yearIndicatorMesh && generatedGeometryData) {
                // Find geometry data at current progress
                const pointCount = generatedGeometryData.length;
                const idx = Math.min(Math.floor(progress * (pointCount - 1)), pointCount - 1);
                
                const ptData = generatedGeometryData[idx];
                
                if (ptData) {
                    const exactYear = ptData.decimalYear;
                    const displayYear = Math.floor(exactYear);
                    const currentAnomaly = ptData.anomaly || 0;
                    
                    // Update Text
                    updateYearIndicatorText(displayYear);
                    
                    // Update Position (based on actual spiral year position, not linear time)
                    const yearOffset = exactYear - startYear;
                    yearIndicatorMesh.position.y = (yearOffset * CONFIG.heightPerYear) + 2; 
                    
                    // Update Panel Info
                    document.getElementById('infoYear').innerText = displayYear;
                    // Calc month from decimal
                    const monthIndex = Math.min(11, Math.floor((exactYear % 1) * 12));
                    document.getElementById('infoMonth').innerText = MONTHS_NAMES[monthIndex];
                    
                    const tempSign = currentAnomaly > 0 ? "+" : "";
                    document.getElementById('infoTemp').innerText = tempSign + currentAnomaly.toFixed(2) + " °C";
                    
                    // Update Legend (FIXED RANGE -1 to 2)
                    // Percent = (val - (-1)) / 3 * 100
                    let percent = (currentAnomaly + 1) / 3 * 100;
                    percent = Math.max(0, Math.min(100, percent)); 
                    document.getElementById('legendMarker').style.left = percent + "%";
                    
                    // Update Color
                    if (ptData.color) {
                        yearIndicatorMesh.material.color.set(ptData.color);
                        document.getElementById('infoTemp').style.color = "#" + ptData.color.getHexString();
                    }
                }
            }
        }

        function toggleAnimation() {
            isAnimating = !isAnimating;
            const playBtn = document.getElementById('playBtn');
            const playIcon = document.getElementById('playIconImg'); 
            const playText = playBtn.querySelector('.btn-text');

            if (isAnimating) {
                if(playIcon) {
                    playIcon.src = 'icons/pause.png';
                    playIcon.alt = 'Pause';
                }
                playText.innerText = '❚❚';
                
                playBtn.classList.add('active');
                playBtn.title = "Pause Animation";
                
                if (animationIndex >= totalIndices) {
                    animationIndex = 0;
                    if (spiralMesh) spiralMesh.geometry.setDrawRange(0, 0);
                }
            } else {
                if(playIcon) {
                    playIcon.src = 'icons/play.png';
                    playIcon.alt = 'Play';
                }
                playText.innerText = '▶';
                
                playBtn.classList.remove('active');
                playBtn.title = "Play Animation";
            }
        }

        function switchCamera(isOrtho) {
            const target = controls.target.clone();
            if (isOrtho) {
                const dist = perspectiveCamera.position.distanceTo(target);
                const fov = perspectiveCamera.fov; 
                const visibleHeight = 2 * dist * Math.tan(THREE.MathUtils.degToRad(fov / 2));
                const frustumHeight = CONFIG.frustumSize; 
                orthographicCamera.zoom = frustumHeight / visibleHeight;
                orthographicCamera.updateProjectionMatrix();
                orthographicCamera.position.copy(perspectiveCamera.position);
                orthographicCamera.rotation.copy(perspectiveCamera.rotation);
                activeCamera = orthographicCamera;
            } else {
                const zoom = orthographicCamera.zoom;
                const frustumHeight = CONFIG.frustumSize;
                const visibleHeight = frustumHeight / zoom;
                const fov = perspectiveCamera.fov;
                const dist = visibleHeight / (2 * Math.tan(THREE.MathUtils.degToRad(fov / 2)));
                const direction = new THREE.Vector3().subVectors(orthographicCamera.position, target).normalize();
                perspectiveCamera.position.copy(target).add(direction.multiplyScalar(dist));
                perspectiveCamera.rotation.copy(orthographicCamera.rotation);
                activeCamera = perspectiveCamera;
            }
            controls.object = activeCamera;
            controls.target.copy(target); 
            controls.update();
        }

        function checkForGaps(data) {
            for (let i = 0; i < data.length - 1; i++) {
                if (data[i+1].year - data[i].year > 1) {
                    return true;
                }
            }
            return false;
        }

        function updateDataVisualization() {
            const rawData = parseGISSData(currentDataText);
            const hasGaps = checkForGaps(rawData);
            const interpRow = document.getElementById('interpolationRow');
            if(interpRow) interpRow.style.display = hasGaps ? 'flex' : 'none';

            const shouldInterpolate = document.getElementById('interpolationToggle').checked;
            const processedData = (hasGaps && shouldInterpolate) ? interpolateSparseData(rawData) : rawData;
            
            timelineData = processedData; 
            
            if (processedData.length > 0) {
                startYear = processedData[0].year;
                const lastEntry = processedData[processedData.length - 1];
                endYear = lastEntry.year;
                
                const yearsDiff = endYear - startYear;
                const monthsInLastYear = lastEntry.anomalies.length;
                
                totalDurationYears = yearsDiff + ((monthsInLastYear - 1) / 12);

                document.getElementById('timelineStart').innerText = startYear;
                document.getElementById('timelineEnd').innerText = endYear;
            }

            createSpiral(processedData);
            createMonthRing(CONFIG.radiusBase + (currentMaxAnomaly * CONFIG.radiusScale) + .5); 
        }

        function createMonthRing(radius) {
            if (monthLabelsGroup) { disposeHierarchy(monthLabelsGroup); scene.remove(monthLabelsGroup); }
            
            monthLabelsGroup = new THREE.Group();
            
            const visible = document.getElementById('helpersToggle').checked;
            monthLabelsGroup.visible = visible;

            const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            
            const azimuthAngle = controls.getAzimuthalAngle();
            const polarAngle = controls.getPolarAngle();
            const topDownThreshold = 1.2;
            const opacityFade = Math.min(1, Math.max(0, polarAngle / topDownThreshold));
            const inverseOpacity = 1 - opacityFade;

            months.forEach((month, index) => {
                const angle = (index / 12) * Math.PI * 2 + CONFIG.angleOffset;
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;

                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = 512; 
                canvas.height = 256;
                
                ctx.fillStyle = '#888'; 
                // Use global font constant
                ctx.font = '100px ' + FONT_FAMILY; 
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(month, 256, 128);

                const texture = new THREE.CanvasTexture(canvas);
                texture.minFilter = THREE.LinearFilter;
                texture.magFilter = THREE.LinearFilter;
                texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
                
                const material = new THREE.MeshBasicMaterial({ 
                    map: texture, 
                    transparent: true,
                    side: THREE.DoubleSide
                });
                
                const geometry = new THREE.PlaneGeometry(6, 3);
                const mesh = new THREE.Mesh(geometry, material);
                
                mesh.position.set(x, 0, z);
                mesh.rotation.x = -Math.PI / 2;
                mesh.position.y = -2.0;
                
                mesh.material.opacity = inverseOpacity;
                mesh.rotation.z = azimuthAngle;

                monthLabelsGroup.add(mesh);
            });
            scene.add(monthLabelsGroup);
            
            const visibleState = document.getElementById('helpersToggle').checked;
            monthLabelsGroup.visible = visibleState;
        }

        function parseGISSData(text) {
            const lines = text.trim().split('\n');
            const data = [];
            const yearRegex = /^\s*(\d{4})/;
            let scaleFactor = 1.0;
            let checkedScale = false;

            lines.forEach(line => {
                if (yearRegex.test(line)) {
                    const parts = line.trim().split(/\s+/);
                    if (parts.length >= 2) {
                        if (!checkedScale) {
                             const rawVal = parts[1].replace(/\*/g, '');
                             const valTest = parseFloat(rawVal);
                             if (!isNaN(valTest) && Math.abs(valTest) > 10) {
                                 scaleFactor = 0.01;
                             }
                             checkedScale = true;
                        }
                        const year = parseInt(parts[0]);
                        const anomalies = [];
                        for (let i = 1; i <= 12; i++) {
                            if (i >= parts.length) break;
                            let raw = parts[i];
                            let clean = raw.replace(/\*/g, '');
                            if (clean === '') break; 
                            let val = parseFloat(clean);
                            if (isNaN(val)) break; 
                            anomalies.push(val * scaleFactor);
                        }
                        if (anomalies.length > 0) {
                            data.push({ year, anomalies });
                        }
                    }
                }
            });
            return data;
        }

        function interpolateSparseData(sparseData) {
            const fullData = [];
            for (let i = 0; i < sparseData.length - 1; i++) {
                const start = sparseData[i];
                const end = sparseData[i+1];
                fullData.push(start);
                const yearsDiff = end.year - start.year;
                if (yearsDiff > 1) {
                    for (let y = 1; y < yearsDiff; y++) {
                        const year = start.year + y;
                        const factor = y / yearsDiff;
                        if(start.anomalies.length === 12 && end.anomalies.length === 12) {
                            const interpolatedAnomalies = start.anomalies.map((val, idx) => {
                                return val + (end.anomalies[idx] - val) * factor;
                            });
                            fullData.push({ year, anomalies: interpolatedAnomalies });
                        }
                    }
                }
            }
            fullData.push(sparseData[sparseData.length - 1]);
            return fullData;
        }

        // --- Custom Geometry Generator (with Caps) ---
        function createDataTubeGeometry(points, colors, radius, radialSegments) {
            const numPoints = points.length;
            const numSegments = numPoints - 1;
            
            // Vertices for the tube: numPoints * radialSegments
            // Extra vertices for caps: 2 (start center, end center)
            const vertexCount = (numPoints * radialSegments) + 2;
            
            const geometry = new THREE.BufferGeometry();
            const positionArray = new Float32Array(vertexCount * 3);
            const colorArray = new Float32Array(vertexCount * 3);
            const indexArray = [];

            const P = new THREE.Vector3();
            const T = new THREE.Vector3();
            const N = new THREE.Vector3();
            const B = new THREE.Vector3();
            
            // --- 1. Generate Tube Vertices ---
            for (let i = 0; i < numPoints; i++) {
                P.copy(points[i]);
                
                if (i === 0) {
                    T.subVectors(points[1], points[0]).normalize();
                } else if (i === numPoints - 1) {
                    T.subVectors(points[i], points[i-1]).normalize();
                } else {
                    const T1 = new THREE.Vector3().subVectors(points[i], points[i-1]);
                    const T2 = new THREE.Vector3().subVectors(points[i+1], points[i]);
                    T.addVectors(T1, T2).normalize();
                }

                N.set(P.x, 0, P.z);
                if (N.lengthSq() < 0.001) N.set(1, 0, 0); 
                N.normalize();

                B.crossVectors(T, N).normalize();
                N.crossVectors(B, T).normalize();

                const baseIndex = i * radialSegments;
                const c = colors[i]; 

                for (let j = 0; j < radialSegments; j++) {
                    const theta = (j / radialSegments) * Math.PI * 2;
                    const sin = Math.sin(theta);
                    const cos = Math.cos(theta);

                    const px = P.x + radius * (cos * N.x + sin * B.x);
                    const py = P.y + radius * (cos * N.y + sin * B.y);
                    const pz = P.z + radius * (cos * N.z + sin * B.z);

                    positionArray[baseIndex*3 + j*3]     = px;
                    positionArray[baseIndex*3 + j*3 + 1] = py;
                    positionArray[baseIndex*3 + j*3 + 2] = pz;

                    colorArray[baseIndex*3 + j*3]     = c.r;
                    colorArray[baseIndex*3 + j*3 + 1] = c.g;
                    colorArray[baseIndex*3 + j*3 + 2] = c.b;
                }
            }
            
            // --- 2. Add Cap Center Vertices ---
            const startCenterIdx = vertexCount - 2;
            positionArray[startCenterIdx*3]     = points[0].x;
            positionArray[startCenterIdx*3 + 1] = points[0].y;
            positionArray[startCenterIdx*3 + 2] = points[0].z;
            colorArray[startCenterIdx*3]     = colors[0].r;
            colorArray[startCenterIdx*3 + 1] = colors[0].g;
            colorArray[startCenterIdx*3 + 2] = colors[0].b;
            
            const endCenterIdx = vertexCount - 1;
            positionArray[endCenterIdx*3]     = points[numPoints-1].x;
            positionArray[endCenterIdx*3 + 1] = points[numPoints-1].y;
            positionArray[endCenterIdx*3 + 2] = points[numPoints-1].z;
            colorArray[endCenterIdx*3]     = colors[numPoints-1].r;
            colorArray[endCenterIdx*3 + 1] = colors[numPoints-1].g;
            colorArray[endCenterIdx*3 + 2] = colors[numPoints-1].b;

            // --- 3. Generate Indices (Fixed Winding for Outward Normals) ---
            
            // Start Cap Indices (Triangle Fan) - Need Backward Normal
            // Center -> nextI -> i produces Backward Normal (Out of tube start)
            for (let j = 0; j < radialSegments; j++) {
                const i = j;
                const nextI = (j + 1) % radialSegments;
                indexArray.push(startCenterIdx, nextI, i);
            }

            // Tube Body Indices - Need CCW Winding for Outward Normal
            // Standard quad (i,j) -> (i,j+1) -> (i+1,j+1) -> (i+1,j)
            // Triangles: (i,j)-(i,j+1)-(i+1,j) and (i,j+1)-(i+1,j+1)-(i+1,j)
            // Indices: a-b-d and b-c-d
            for (let i = 0; i < numSegments; i++) {
                for (let j = 0; j < radialSegments; j++) {
                    const nextJ = (j + 1) % radialSegments;
                    
                    const a = i * radialSegments + j;
                    const b = i * radialSegments + nextJ;
                    const c = (i + 1) * radialSegments + nextJ;
                    const d = (i + 1) * radialSegments + j;

                    indexArray.push(a, b, d);
                    indexArray.push(b, c, d);
                }
            }
            
            // End Cap Indices (Triangle Fan) - Need Forward Normal
            // Center -> i -> nextI produces Forward Normal (Out of tube end)
            const lastRingStart = (numPoints - 1) * radialSegments;
            for (let j = 0; j < radialSegments; j++) {
                const i = lastRingStart + j;
                const nextI = lastRingStart + ((j + 1) % radialSegments);
                indexArray.push(endCenterIdx, i, nextI);
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positionArray, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colorArray, 3));
            geometry.setIndex(indexArray);
            geometry.computeVertexNormals();
            
            return geometry;
        }

        function createSpiral(data) {
            if (spiralMesh) { disposeHierarchy(spiralMesh); scene.remove(spiralMesh); }
            if (endCapMesh) { disposeHierarchy(endCapMesh); scene.remove(endCapMesh); }
            if (yearLabelsGroup) { disposeHierarchy(yearLabelsGroup); scene.remove(yearLabelsGroup); }

            const rawPoints = [];
            const rawColors = [];
            const rawMetaData = []; // To store year info per point
            const yearLabels = new THREE.Group();
            
            const visible = document.getElementById('helpersToggle').checked;
            yearLabels.visible = visible;

            const startYearData = data[0].year;
            currentMaxAnomaly = -Infinity;
            currentMinAnomaly = Infinity;

            data.forEach((entry) => {
                entry.anomalies.forEach((val) => {
                    if (val > currentMaxAnomaly) currentMaxAnomaly = val;
                    if (val < currentMinAnomaly) currentMinAnomaly = val;
                });
            });
            
            const azimuthAngle = controls.getAzimuthalAngle();
            const polarAngle = controls.getPolarAngle();
            const topDownThreshold = 1.2;
            const opacityFade = Math.min(1, Math.max(0, polarAngle / topDownThreshold));

            // 1. Generate Raw Data Points (One per month)
            data.forEach((entry, yearIdx) => {
                entry.anomalies.forEach((anomaly, monthIdx) => {
                    const angle = (monthIdx / 12) * Math.PI * 2 + CONFIG.angleOffset;
                    const r = CONFIG.radiusBase + (anomaly * CONFIG.radiusScale);
                    const yearOffset = entry.year - startYearData;
                    const yPos = (yearOffset + (monthIdx / 12)) * CONFIG.heightPerYear;

                    const x = Math.cos(angle) * r;
                    const z = Math.sin(angle) * r;

                    rawPoints.push(new THREE.Vector3(x, yPos, z));
                    
                    // Metadata for timeline
                    rawMetaData.push({
                        decimalYear: entry.year + (monthIdx / 12),
                        anomaly: anomaly,
                        // Store tangent basis later if needed, but we calculate it in geometry gen now
                        // For endCapMesh alignment, we still need tangent
                    });

                    // Color calculation (FIXED SPECTRUM)
                    let c = new THREE.Color();
                    if (anomaly < 0) {
                        const t = Math.min(1, Math.abs(anomaly));
                        c.lerpColors(CONFIG.colors.neutral, CONFIG.colors.cold, t);
                    } else if (anomaly <= 1) {
                        c.lerpColors(CONFIG.colors.neutral, CONFIG.colors.hot, anomaly);
                    } else {
                        const t = Math.min(1, anomaly - 1);
                        c.lerpColors(CONFIG.colors.hot, CONFIG.colors.extreme, t);
                    }
                    rawColors.push(c);
                });

                if (entry.year % 10 === 0) {
                    const yearOffset = entry.year - startYearData;
                    const y = (yearOffset) * CONFIG.heightPerYear;
                    const sprite = addYearLabel(entry.year, y);
                    sprite.material.opacity = opacityFade;
                    yearLabels.add(sprite);
                }
            });
            
            // Add next decade label
            const lastEntry = data[data.length - 1];
            const lastYear = lastEntry.year;
            // E.g. if lastYear is 2025 -> 2030. If 2030 -> 2040.
            const nextDecade = Math.floor(lastYear / 10) * 10 + 10;
            const yearOffset = nextDecade - startYearData;
            const y = yearOffset * CONFIG.heightPerYear;
            const sprite = addYearLabel(nextDecade, y);
            sprite.material.opacity = opacityFade;
            yearLabels.add(sprite);
            
            yearLabels.rotation.y = azimuthAngle;
            spiralHeight = (data[data.length-1].year - startYearData + 1) * CONFIG.heightPerYear;
            updateTemperatureVerticals(spiralHeight);

            if (rawPoints.length < 2) return;

            // 2. Smooth vs Rough Generation
            const isSmooth = document.getElementById('smoothSpiralToggle').checked;
            
            let finalPoints = [];
            let finalColors = [];
            let finalMetaData = []; // To store interpolated year info
            
            if (isSmooth) {
                const curve = new THREE.CatmullRomCurve3(rawPoints);
                curve.curveType = 'centripetal'; 
                
                const pointsPerSeg = 6; 
                const totalPoints = (rawPoints.length - 1) * pointsPerSeg + 1;
                
                finalPoints = curve.getPoints(totalPoints); 
                
                for (let i = 0; i < finalPoints.length; i++) {
                    const u = i / (finalPoints.length - 1);
                    const floatIdx = u * (rawPoints.length - 1);
                    const idxA = Math.floor(floatIdx);
                    const idxB = Math.min(idxA + 1, rawPoints.length - 1);
                    const alpha = floatIdx - idxA;
                    
                    finalColors.push(lerpColor(rawColors[idxA], rawColors[idxB], alpha));
                    
                    const yearA = rawMetaData[idxA].decimalYear;
                    const yearB = rawMetaData[idxB].decimalYear;
                    const interpYear = yearA + (yearB - yearA) * alpha;
                    
                    const valA = rawMetaData[idxA].anomaly;
                    const valB = rawMetaData[idxB].anomaly;
                    const interpVal = valA + (valB - valA) * alpha;
                    
                    finalMetaData.push({
                        decimalYear: interpYear,
                        anomaly: interpVal
                    });
                }
                
            } else {
                finalPoints = rawPoints;
                finalColors = rawColors;
                finalMetaData = rawMetaData;
            }

            // 3. Generate Custom Geometry with Caps
            const geometry = createDataTubeGeometry(finalPoints, finalColors, CONFIG.tubeRadius, CONFIG.radialSegments);
            
            // --- NEW: Store original colors for highlight effect ---
            const colorAttr = geometry.attributes.color;
            // Store as a Float32Array in userData
            geometry.userData.originalColorArray = new Float32Array(colorAttr.array);
            geometry.userData.lastTailRange = { start: 0, end: -1 }; // Empty start

            // Store data for animation mapping
            generatedGeometryData = finalPoints.map((p, i) => ({
                point: p,
                color: finalColors[i],
                decimalYear: finalMetaData[i].decimalYear,
                anomaly: finalMetaData[i].anomaly
            }));

            const material = new THREE.MeshStandardMaterial({
                vertexColors: true,
                roughness: 0.3,
                metalness: 0.0, 
            });

            spiralMesh = new THREE.Mesh(geometry, material);
            scene.add(spiralMesh);

            scene.add(yearLabels);
            yearLabelsGroup = yearLabels;
            
            // Moving End Cap (Lid) - Separate Mesh for Animation
            // CircleGeometry(radius, 8) creates an octagon
            const endCapGeo = new THREE.CircleGeometry(CONFIG.tubeRadius, 8);
            const endCapMat = new THREE.MeshStandardMaterial({
                roughness: 0.3,
                metalness: 0.0,
                color: finalColors[0],
                side: THREE.DoubleSide
            });
            
            endCapMesh = new THREE.Mesh(endCapGeo, endCapMat);
            endCapMesh.visible = visible;
            scene.add(endCapMesh);

            controls.target.set(0, spiralHeight / 2, 0);
            
            // Total indices needed for FULL draw (Body + Start Cap + End Cap)
            // However, animation only grows the body.
            // Start cap indices = radialSegments * 3
            const startCapIndices = CONFIG.radialSegments * 3;
            // Body indices = (numPoints-1) * radialSegments * 6
            const bodyIndices = (finalPoints.length - 1) * CONFIG.radialSegments * 6;
            
            totalIndices = bodyIndices; // For animation progress calculation
            
            if (!isAnimating) {
                // Show full geometry including end cap
                geometry.setDrawRange(0, Infinity);
                animationIndex = totalIndices;
                document.getElementById('timelineSlider').value = 100;
                
                // Hide moving lid at end, rely on baked geometry
                endCapMesh.visible = false;
                
                updateYearIndicatorText(endYear);
            }
        }

        function addYearLabel(year, y) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 512;
            canvas.height = 256;
            ctx.fillStyle = '#eee';
            ctx.font = '120px ' + FONT_FAMILY; 
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(year, 256, 128);

            const texture = new THREE.CanvasTexture(canvas);
            texture.minFilter = THREE.LinearFilter;
            texture.magFilter = THREE.LinearFilter;
            texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
            
            const spriteMat = new THREE.SpriteMaterial({ map: texture, transparent: true });
            const sprite = new THREE.Sprite(spriteMat);
            sprite.scale.set(6, 3, 1);
            
            sprite.position.set(CONFIG.radiusBase + 10, y, 0);
            return sprite;
        }

        function onWindowResize() {
            const aspect = window.innerWidth / window.innerHeight;
            const frustumSize = CONFIG.frustumSize;

            renderer.setSize(window.innerWidth, window.innerHeight);

            perspectiveCamera.aspect = aspect;
            perspectiveCamera.updateProjectionMatrix();

            let adjustedFrustum = frustumSize;
            if (aspect < 1) {
                const targetWidth = 45; 
                adjustedFrustum = targetWidth / aspect; 
            }

            orthographicCamera.left = -adjustedFrustum * aspect / 2;
            orthographicCamera.right = adjustedFrustum * aspect / 2;
            orthographicCamera.top = adjustedFrustum / 2;
            orthographicCamera.bottom = -adjustedFrustum / 2;
            orthographicCamera.updateProjectionMatrix();
        }
        
        function updateSpiralVisuals() {
            if (!spiralMesh) return;

            // Snap to full rings to prevent spikes
            // Each segment (ring to ring) uses 6 * radial indices
            const stride = CONFIG.radialSegments * 6;
            const snappedIndex = Math.floor(animationIndex / stride) * stride;
            const startCapIndices = CONFIG.radialSegments * 3;
            
            // Draw Start Cap + Current Body
            spiralMesh.geometry.setDrawRange(0, startCapIndices + snappedIndex);

            // --- Highlight Logic ---
            const currentRingIndex = Math.floor(snappedIndex / stride);
            const radial = CONFIG.radialSegments;
            const colorAttr = spiralMesh.geometry.attributes.color;
            const originals = spiralMesh.geometry.userData.originalColorArray;
            const lastRange = spiralMesh.geometry.userData.lastTailRange;

            // 1. Restore previous tail to original colors
            // Optimization: Only restore if valid range
            if (lastRange.end >= lastRange.start) {
                for (let r = lastRange.start; r <= lastRange.end; r++) {
                    const ringStartIdx = r * radial * 3;
                    const ringEndIdx = (r + 1) * radial * 3;
                    for (let k = ringStartIdx; k < ringEndIdx; k++) {
                        colorAttr.array[k] = originals[k];
                    }
                }
            }

            // Check if we are at the end of the animation
            if (animationIndex >= totalIndices) {
                 colorAttr.needsUpdate = true;
                 spiralMesh.geometry.userData.lastTailRange = { start: 0, end: -1 };
                 if(endCapMesh) endCapMesh.visible = false;
                 // Show full geometry including baked end cap
                 spiralMesh.geometry.setDrawRange(0, Infinity);
                 return; 
            }

            // 2. Apply new tail gradient
            // Tail length in rings (1 month approx 6 rings)
            const tailLen = 24; // ~4 months trail
            const startRing = Math.max(0, currentRingIndex - tailLen);
            const endRing = currentRingIndex; // Highlight up to the current tip
            
            const white = new THREE.Color(1, 1, 1);
            const tempColor = new THREE.Color();

            for (let r = startRing; r <= endRing; r++) {
                // Safety check
                if ((r + 1) * radial * 3 > colorAttr.array.length) continue;

                let alpha = (r - startRing) / (endRing - startRing || 1);
                // Non-linear for "hot" tip
                alpha = Math.pow(alpha, 5); 

                for (let j = 0; j < radial; j++) {
                    const idx = (r * radial + j) * 3;
                    
                    tempColor.setRGB(originals[idx], originals[idx+1], originals[idx+2]);
                    tempColor.lerp(white, alpha);
                    
                    colorAttr.array[idx] = tempColor.r;
                    colorAttr.array[idx+1] = tempColor.g;
                    colorAttr.array[idx+2] = tempColor.b;
                }
            }
            
            colorAttr.needsUpdate = true;
            spiralMesh.geometry.userData.lastTailRange = { start: startRing, end: endRing };
            
            // Moving Lid Logic
            if (endCapMesh && generatedGeometryData) {
                const segmentIdx = snappedIndex / stride;
                const ptIndex = Math.min(segmentIdx, generatedGeometryData.length - 1);
                const data = generatedGeometryData[ptIndex];
                
                if (data) {
                    endCapMesh.visible = true; // Always visible during animation
                    endCapMesh.position.copy(data.point);
                    endCapMesh.material.color.setHex(0xffffff); // Highlight tip white
                    
                    // Align Lid Rotation
                    // We need the tangent. Let's compute it on the fly or store it.
                    // Simple hack: Look at next point (or previous if at end)
                    let targetPoint;
                    if (ptIndex < generatedGeometryData.length - 1) {
                        targetPoint = generatedGeometryData[ptIndex + 1].point;
                    } else if (ptIndex > 0) {
                        // Extrapolate direction
                        const prev = generatedGeometryData[ptIndex - 1].point;
                        const dir = new THREE.Vector3().subVectors(data.point, prev);
                        targetPoint = new THREE.Vector3().addVectors(data.point, dir);
                    }
                    
                    if (targetPoint) {
                        endCapMesh.lookAt(targetPoint);
                    }
                }
            }
        }
        
        function updateAnimation() {
            if (!isAnimating || !spiralMesh) return;
            
            const baseSpeed = Math.ceil(totalIndices / 600); 
            const speed = baseSpeed * animationSpeed;
            
            animationIndex += speed;
            
            if (animationIndex >= totalIndices) {
                animationIndex = totalIndices;
                toggleAnimation(); 
                
                // Show baked end cap, hide moving lid
                spiralMesh.geometry.setDrawRange(0, Infinity);
                if(endCapMesh) endCapMesh.visible = false;

                // Remove highlight (restores original colors)
                updateSpiralVisuals(); 
                
            } else {
                updateSpiralVisuals();
            }
            
            document.getElementById('timelineSlider').value = (animationIndex / totalIndices) * 100;
            updateTimelineState(animationIndex);
        }

        function animate() {
            requestAnimationFrame(animate);
            updateAnimation();
            controls.update();
            
            // Sync Directional Light with Camera
            if (dirLight && activeCamera) {
                 dirLight.position.copy(activeCamera.position);
            }

            const polarAngle = controls.getPolarAngle();
            const topDownThreshold = 1.2; 
            const opacityFade = Math.min(1, Math.max(0, polarAngle / topDownThreshold));
            const inverseOpacity = 1 - opacityFade; 
            const azimuthAngle = controls.getAzimuthalAngle();

            if (yearLabelsGroup) {
                yearLabelsGroup.children.forEach(sprite => {
                    sprite.material.opacity = opacityFade;
                });
                yearLabelsGroup.rotation.y = azimuthAngle;
            }
            
            if (tempVerticalGroup) {
                tempVerticalGroup.rotation.y = azimuthAngle;
                
                tempVerticalGroup.children.forEach(child => {
                    if (child.name === "vLabel") {
                         child.material.opacity = opacityFade * 0.6; // Change to 0.6
                    } else {
                         child.material.opacity = opacityFade * 0.4;
                    }
                });
            }
            
            if (yearIndicatorMesh) {
                yearIndicatorMesh.material.opacity = inverseOpacity;
                yearIndicatorMesh.rotation.z = azimuthAngle;
            }
            
            if (monthLabelsGroup) {
                monthLabelsGroup.children.forEach(mesh => {
                    mesh.material.opacity = inverseOpacity * 0.6; // Change to inverseOpacity * 0.6
                    mesh.rotation.z = azimuthAngle;
                });
            }
            
            if(tempGridGroup) {
                tempGridGroup.children.forEach(child => {
                     if(child.material) child.material.opacity = inverseOpacity * 0.3;
                });
            }
            
            if(tempLabelGroup) {
                 tempLabelGroup.rotation.y = azimuthAngle;
                 tempLabelGroup.children.forEach(sprite => {
                     sprite.material.opacity = inverseOpacity * 0.6; // Reference value
                 });
            }

            renderer.render(scene, activeCamera);
        }
    </script>
</body>
</html>